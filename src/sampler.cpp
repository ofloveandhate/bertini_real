#include "sampler.hpp"











int main(int argC, char *args[])
{
	
	boost::timer::auto_cpu_timer t;
	
	
	MPI_Init(&argC,&args);
	
	
	int num_vars=0;
	boost::filesystem::path inputName, witnessSetName, samplingNamenew;
	
	
	
	
	curve_sample_data   S_old,S_new;
    
	
	
	srand(time(NULL));
	
	
	sampler_configuration sampler_options;
	
	sampler_options.splash_screen();
	sampler_options.parse_commandline(argC, args);
    
	int MPType, dimension;
	
	boost::filesystem::path directoryName;
	
	get_dir_mptype_dimen( directoryName, MPType, dimension);
	
	
	
	vertex_set V;
	V.setup_vertices(directoryName / "V.vertex"); //setup V structure from V.vertex
	
    
	
	witnessSetName = directoryName / "witness_set";
	samplingNamenew = directoryName / "samp.dat";
	
	
	solver_configuration solve_options;
	
	curve_decomposition C;
	surface_decomposition surf_input;
	
	decomposition * decom_pointy;
	switch (dimension) {
		case 1:
		{
			//read in the gross information from the summary file.
			C.setup(directoryName);
			
			decom_pointy = &C;
			
		}
			break;
			
		case 2:
		{
			std::cout << "reading surface" << std::endl;
			surf_input.setup(directoryName);
			decom_pointy = &surf_input;
		}
			break;
			
		default:
		{
			std::cout << "sampler not capable of sampling anything but dimension 1 or 2.  this is of dim " << dimension << std::endl;
			return 0;
		}
			break;
	}
	
	
	
	
	common_sampler_startup(*decom_pointy);// this does nothing so far.  want to abstract it.
	
	
	
	std::cout << decom_pointy->input_filename << std::endl;
	
	parse_input_file(decom_pointy->input_filename); // restores all the temp files generated by the parser, to this folder.  i think this can be removed?  but the PPD and tracker config both depend on it...  so maybe not.
	
    
	
	// set up the solver configuration
	get_tracker_config(solve_options,MPType);
	parse_preproc_data("preproc_data", &solve_options.PPD);
    
	initMP(solve_options.T.Precision);
	num_vars = get_num_vars_PPD(solve_options.PPD);
	
	
    
    
	
	
	
	witness_set W;
	
	W.input_filename = decom_pointy->input_filename;
	W.num_variables = decom_pointy->num_variables;
	W.num_synth_vars = decom_pointy->num_variables - V.num_natural_variables;
    
	W.get_variable_names();
	
    //	W.witnessSetParse(witnessSetName,num_vars);
	
	
	W.reset_patches(); // is this necessary?  i don't think so, only if we actually parse from file and get patches as a result.  then again, it probably doesn't hurt.
	for (int ii=0; ii<decom_pointy->num_patches; ii++) {
		W.add_patch(decom_pointy->patch[ii]);
	}
	
	

	
	mat_mp randomizer_matrix; init_mat_mp2(randomizer_matrix, 0,0, solve_options.T.AMP_max_prec);
	
	//create the vector of integers
	std::vector< int > randomized_degrees;
	
	//get the matrix and the degrees of the resulting randomized functions.
	make_randomization_matrix_based_on_degrees(randomizer_matrix, randomized_degrees, W.num_variables-W.num_patches-1, solve_options.PPD.num_funcs);
	
	
	
	
	
    
	solve_options.verbose_level = sampler_options.verbose_level;
	if (solve_options.verbose_level>=2) {
		solve_options.show_status_summary=1;
	}
	
	
	
	
	
	
	solve_options.T.ratioTol = 0.99999999; // manually assert to be more permissive.  i don't really like this.
	
	
	
	solve_options.use_midpoint_checker = 0;
	solve_options.use_gamma_trick = sampler_options.use_gamma_trick;
	solve_options.allow_singular = 1;
    solve_options.robust = true;
	/////////
	////////
	//////
	////
	//
	//  Generate new sampling data
	//
    

	switch (dimension) {
		case 1:
		{
			curve_generate_new_sampling_pts_adaptive(&S_new,
													 randomizer_matrix,
													 S_old,
													 C,
													 V,
													 W,
													 MPType,
													 sampler_options,
													 solve_options);
			
			
			//output
			output_sampling_data(S_new,V,
								 samplingNamenew,num_vars,MPType);
			
		}
			break;
			
		case 2:
		{
			
		}
			break;
		default:
			break;
	}
    
	
	
	
    
	//
	//   Done with the main call
	////
	/////
	///////
	////////
	
	
	
	
	
    
    
	
	clear_mat_mp(randomizer_matrix);
    

	
	clearMP();
	MPI_Finalize();
	
	return 0;
}



void common_sampler_startup(const decomposition & D)
{
	
}


void curve_generate_new_sampling_pts_adaptive(curve_sample_data *S_new,
											  mat_mp randomizer_matrix,
											  curve_sample_data & S_old,
											  curve_decomposition & C,
											  vertex_set &V,
											  witness_set & W,
											  int MPType,
											  sampler_configuration & sampler_options,
											  solver_configuration & solve_options)
{
    
	
	set_initial_sample_data(S_old,C,V,
                            C.num_variables);
	
	
	V.set_curr_projection(C.pi[0]);
	V.set_curr_input(W.input_filename);
	
	
	
	int	num_vars = C.num_variables;
	
	
	witness_set Wnew;
	
	
	vec_mp target_projection;
	init_vec_mp(target_projection,num_vars); target_projection->size = num_vars;
	vec_cp_mp(target_projection,C.pi[0]); // copy the projection into target_projection
	
	
	vec_mp startpt;
	init_vec_mp(startpt,num_vars); startpt->size = num_vars;
	
	
	vec_mp start_projection;
	init_vec_mp(start_projection,num_vars);  start_projection->size = num_vars;
	vec_cp_mp(start_projection,C.pi[0]); // grab the projection, copy it into start_projection
	

	
	
	comp_mp temp, temp1, target_projection_value;
	init_mp(temp);  init_mp(temp1); init_mp(target_projection_value);
    
	int prev_num_samp, sample_counter;
	std::vector<bool> refine_current, refine_next;
	
	
	
	S_new->num_variables = C.num_variables;
	S_new->num_edges = S_old.num_edges;
	
	
	S_new->num_samples_each_edge.resize(S_new->num_edges);
	S_new->sample_indices.resize(S_new->num_edges);
	

	
	vertex temp_vertex;
    
	mpf_t dist_away; mpf_init(dist_away);
	int interval_counter;
	int num_refinements;
	std::vector<int> current_indices;
	
	multilin_config ml_config(solve_options,randomizer_matrix);
	
	std::cout << S_old.num_edges << std::endl;
	
	
	for(int ii=0;ii<S_old.num_edges;ii++) // for each of the edges
	{
        
		set_initial_refinement_flags(num_refinements,
                                     refine_current,
                                     current_indices,
                                     S_old, V,
                                     ii, sampler_options);
		
		prev_num_samp = S_old.num_samples_each_edge[ii]; // grab the number of points from the array of integers
		
		
		
		int pass_number  = 0;//this should be the only place this is reset.
		while(1) // breaking condition is all samples being less than TOL away from each other (in the infty norm sense).
		{
            
			refine_next.resize(prev_num_samp+num_refinements-1);; // allocate refinement flag
            
			std::vector<int> new_indices;
			new_indices.resize(prev_num_samp+num_refinements);
			
			new_indices[0] = current_indices[0];
			sample_counter = 1; // this will be incremented every time we put a point into new_points
								// starts at 1 because already committed one.
								// this should be the only place this counter is reset.
			
			
			if (sampler_options.verbose_level>=0)
				printf("edge %d, pass %d, %d refinements\n",ii,pass_number,num_refinements);
			
			if (sampler_options.verbose_level>=1) {
				printf("the current indices:\n");
				for (int jj=0; jj<prev_num_samp; jj++)
					printf("%d ",current_indices[jj]);
				printf("\n\n");
			}
			
			if (sampler_options.verbose_level>=1) {
				printf("refine_flag:\n");
				for (int jj=0; jj<prev_num_samp-1; jj++) {
                    printf("%s ",refine_current[jj]?"1":"0");
				}
				printf("\n\n");
			}
			
            
			
			num_refinements = 0; // reset this counter.  this should be the only place this is reset
			interval_counter = 0;
			for(int jj=0; jj<prev_num_samp-1; jj++) // for each interval in the previous set
			{
				
				
				
				if (sampler_options.verbose_level>=2)
					printf("interval %d of %d\n",jj,prev_num_samp-1);
				
				
				
				int startpt_index; int left_index; int right_index;
				
				// set the starting projection and point.
				if(jj==0){// if on the first sample, go the right
					startpt_index = current_indices[1]; //right!
				}
				else{ //go to the left
					startpt_index = current_indices[jj]; // left!
				}
				
				left_index = current_indices[jj];
				right_index = current_indices[jj+1];
				
				
				if (new_indices[sample_counter-1]!=left_index) {
					printf("index mismatch\n");
					exit(1);
				}
				
                
				
				if(refine_current[jj]==1) //
				{
                    
					vec_cp_mp(startpt,V.vertices[startpt_index].pt_mp);
					set_mp(&(start_projection->coord[0]), &V.vertices[startpt_index].projection_values->coord[0]);
					neg_mp(&(start_projection->coord[0]), &(start_projection->coord[0]));
					
					
					estimate_new_projection_value(target_projection_value,				// the new value
                                                  V.vertices[left_index].pt_mp,	//
                                                  V.vertices[right_index].pt_mp, // two points input
                                                  C.pi[0]);												// projection (in homogeneous coordinates)
					
					
                    
					neg_mp(&target_projection->coord[0],target_projection_value); // take the opposite :)
					
					
					set_witness_set_mp(&W, start_projection,startpt,num_vars); // set the witness point and linear in the input for the lintolin solver.
					
                    
					if (sampler_options.verbose_level>=3) {
						print_point_to_screen_matlab(W.pts_mp[0],"startpt");
						print_comp_matlab(&W.L_mp[0]->coord[0],"initial_projection_value");
						print_comp_matlab(target_projection_value,"target_projection_value");
					}
					
					if (sampler_options.verbose_level>=5)
						W.print_to_screen();
					
					if (sampler_options.verbose_level>=10) {
						mypause();
					}
					
					
					
					multilin_solver_master_entry_point(W,         // witness_set
                                                       &Wnew, // the new data is put here!
                                                       &target_projection,
                                                       ml_config,
                                                       solve_options);
					
					
					if (sampler_options.verbose_level>=3)
						print_point_to_screen_matlab(Wnew.pts_mp[0], "new_solution");
					
					
					
					
					
					// check how far away we were from the LEFT interval point
					norm_of_difference(dist_away,
                                       Wnew.pts_mp[0], // the current new point
                                       V.vertices[left_index].pt_mp);// jj is left, jj+1 is right
					
					if ( mpf_cmp(dist_away, sampler_options.TOL )>0 ){
						refine_next[interval_counter] = true;
						num_refinements++;
					}
					else{
                        refine_next[interval_counter] = false;
					}
					interval_counter++;
					
					
					
					
					// check how far away we were from the RIGHT interval point
					norm_of_difference(dist_away,
                                       Wnew.pts_mp[0], // the current new point
                                       V.vertices[right_index].pt_mp);
					
					if (mpf_cmp(dist_away, sampler_options.TOL ) > 0){
						refine_next[interval_counter] = 1;
						num_refinements++;
					}
					else{
						refine_next[interval_counter] = 0;
					}
					interval_counter++;
					
					
					vec_cp_mp(temp_vertex.pt_mp,Wnew.pts_mp[0]);
					temp_vertex.type = SAMPLE_POINT;
					
                    
					new_indices[sample_counter] = V.add_vertex(temp_vertex);
					sample_counter++;
					
					new_indices[sample_counter] = right_index;
					sample_counter++;
                    
					Wnew.reset();
					
				}
				else {
					if (sampler_options.verbose_level>=2)
						printf("adding sample %d\n",sample_counter);
					
					refine_next[interval_counter] = 0;
					new_indices[sample_counter] = right_index;
					interval_counter++;
					sample_counter++;
				}
			}
            
			
			if (sampler_options.verbose_level>=1) // print by default
				printf("\n\n");
			
			if( (num_refinements == 0) || (pass_number >= sampler_options.maximum_num_iterations) ) // if have no need for new samples
			{
				
				if (sampler_options.verbose_level>=1) // print by default
					printf("breaking\nsample_counter = %d\n",sample_counter);
				
				
				S_new->sample_indices[ii].swap(new_indices);
				S_new->num_samples_each_edge[ii] = sample_counter;
                
				break; // BREAKS THE WHILE LOOP
			}
			else{
				
				refine_current = refine_next; // reassign this pointer
				current_indices.swap(new_indices);
                
				prev_num_samp=sample_counter; // update the number of samples
				pass_number++;
			}
            
		}//while loop
		if (sampler_options.verbose_level>=2) {
			printf("exiting while loop\n");
		}
		printf("\n");
	}  // re: ii (for each edge)
	
	
	
	
	clear_mp(temp); clear_mp(temp1);
	clear_vec_mp(start_projection);
	clear_vec_mp(target_projection);
}








void set_witness_set_mp(witness_set *W, vec_mp new_linear,vec_mp pts,int num_vars)
{
	
	W->num_variables = num_vars;
	
	W->num_pts=1;
	W->pts_mp=(point_mp *)br_malloc(sizeof(point_mp)); // apparently you can only pass in a single point to copy in.
	
	//initialize the memory
	init_point_mp(W->pts_mp[0],num_vars); W->pts_mp[0]->size = num_vars;
	point_cp_mp(W->pts_mp[0],pts);
	
	
	W->num_linears = 1;
	W->L_mp = (vec_mp *)br_malloc(sizeof(vec_mp));
	init_vec_mp(W->L_mp[0],num_vars); W->L_mp[0]->size = num_vars;
	vec_cp_mp(W->L_mp[0],new_linear);
	
}


void  output_sampling_data(curve_sample_data S, vertex_set V,
                           boost::filesystem::path samplingName,int num_vars, int MPType)
{

	
	FILE *OUT =  safe_fopen_write(samplingName);
	int ii,jj,kk;
	// output the number of vertices
	fprintf(OUT,"%d\n\n",S.num_edges);
	for (ii=0; ii<S.num_edges; ii++) {
		
		
		fprintf(OUT,"%d\n\n",S.num_samples_each_edge[ii]);
		for (jj=0; jj<S.num_samples_each_edge[ii]; jj++) {
            //			std::cout << "edge " << ii << " sample " << jj << " " << S.sample_indices[ii][jj] << std::endl;
            //			V.vertices[S.sample_indices[ii][jj]].print();
			
			
			print_mp(OUT,0, &V.vertices[S.sample_indices[ii][jj]].projection_values->coord[0]);
			
			fprintf(OUT,"\n");
			for(kk=0;kk<num_vars;kk++) {
				print_mp(OUT, 0, &V.vertices[S.sample_indices[ii][jj]].pt_mp->coord[kk]);
				fprintf(OUT,"\n");
			}
			fprintf(OUT,"\n");
		}
	}
}





int get_dir_mptype_dimen(boost::filesystem::path & Dir_Name, int & MPType, int & dimension){
    
	std::string tempstr;
	std::ifstream fin("Dir_Name");
	fin >> tempstr;
	fin >> MPType;
	fin >> dimension;
	
	Dir_Name = tempstr;
	return MPType;
}












//dehomogenizes, takes the average, computes the projection.
//takes in the full projection \pi, including the homogenizing coordinate.
void estimate_new_projection_value(comp_mp result, vec_mp left, vec_mp right, vec_mp pi){
	int ii;
	
	if (left->size != right->size) {
		printf("attempting to estimate_new_projection_value on vectors of different size\n");
		deliberate_segfault();
	}
	
    //	print_point_to_screen_matlab(left,"left");
    //	print_point_to_screen_matlab(right,"right");
    //	print_point_to_screen_matlab(pi,"pi");
	
	vec_mp dehom_left, dehom_right;
	init_vec_mp(dehom_left,left->size-1);   dehom_left->size  = left->size-1;
	init_vec_mp(dehom_right,right->size-1); dehom_right->size = right->size-1;
	
	dehomogenize(&dehom_left,left,pi->size);
	dehomogenize(&dehom_right,right,pi->size);
	
	
	comp_mp temp, temp2, half; init_mp(temp); init_mp(temp2);  init_mp(half);
	
	mpf_set_d(half->r, 0.5); mpf_set_d(half->i, 0.0);
	
    
	set_zero_mp(result);                                           // result = 0;  initialize
	
	for (ii = 0; ii<pi->size-1; ii++) {
		add_mp(temp,&dehom_left->coord[ii],&dehom_right->coord[ii]); //  a = (x+y)
		mul_mp(temp2, temp, half);                                   //  b = a/2
		mul_mp(temp,&pi->coord[ii+1],temp2);                          //  a = b.pi
		set_mp(temp2,result);                                        //  b = result
		add_mp(result, temp, temp2);                                  //  result = a+b
	}
    
	
	// in other words, result += (x+y)/2 \cdot pi
    
	mpf_t zerothresh; mpf_init(zerothresh);
	mpf_set_d(zerothresh, 1e-9);
	if (mpf_cmp(result->i, zerothresh) < 0){
		mpf_set_d(result->i, 0.0);
	}
	
	clear_mp(temp); clear_mp(temp2); clear_mp(half);
	mpf_clear(zerothresh);
	clear_vec_mp(dehom_right);clear_vec_mp(dehom_left);
	
	return;
}




int  set_initial_sample_data(curve_sample_data & S, const curve_decomposition & C, vertex_set V,
                             int num_vars)
{

	
	S.num_variables = num_vars;
	S.num_edges = C.num_edges;
	
	S.num_samples_each_edge.resize(C.num_edges);
	
	for(int ii=0; ii<C.num_edges; ii++){
		S.num_samples_each_edge[ii]=3; // left, right, mid
	}
	
	
	S.sample_indices.resize(C.num_edges);
	
	for(int ii=0; ii<S.num_edges; ii++)
	{
		S.sample_indices[ii].resize(3);
		
		S.sample_indices[ii][0] = C.edges[ii].left;
		S.sample_indices[ii][1] = C.edges[ii].midpt;
		S.sample_indices[ii][2] = C.edges[ii].right;
		
	}
	
	return 0;
}




void set_initial_refinement_flags(int & num_refinements, std::vector<bool> & refine_flags, std::vector<int> & current_indices,
                                  const curve_sample_data & S, vertex_set &V,
                                  int current_edge, sampler_configuration & sampler_options)
{
	
	num_refinements = 0; // reset to 0
	refine_flags.resize(S.num_samples_each_edge[current_edge]-1);

	current_indices.resize(S.num_samples_each_edge[current_edge]);

	mpf_t dist_away;  mpf_init(dist_away);
	
	vec_mp temp1, temp2;  init_vec_mp(temp1,S.num_variables-1); init_vec_mp(temp2,S.num_variables-1);
	temp1->size = temp2->size = S.num_variables-1;
	
	current_indices[0] = S.sample_indices[current_edge][0];
	for (int ii=0; ii<(S.num_samples_each_edge[current_edge]-1); ii++) {
		refine_flags[ii] = false;
		
		
		current_indices[ii+1] = S.sample_indices[current_edge][ii+1];
		
		for (int jj=0; jj<S.num_variables-1; jj++) {
			div_mp(&temp1->coord[jj],
                   &V.vertices[S.sample_indices[current_edge][ii]].pt_mp->coord[jj+1],
                   &V.vertices[S.sample_indices[current_edge][ii]].pt_mp->coord[0]);
			
			div_mp(&temp2->coord[jj],
                   &V.vertices[S.sample_indices[current_edge][ii+1]].pt_mp->coord[jj+1],
                   &V.vertices[S.sample_indices[current_edge][ii+1]].pt_mp->coord[0]);
		}
		norm_of_difference(dist_away, temp1,
                           temp2); // get the distance between the two adjacent points.
		if ( mpf_cmp(dist_away, sampler_options.TOL)>0 ){
			refine_flags[ii] = true;
			num_refinements++;
		}
	}
    //	printf("done setting refinement flags\n");
	mpf_clear(dist_away);
}




